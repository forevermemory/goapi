package db

import (
	"net/url"
	"regexp"
	"strconv"
	"strings"
)

// ?page=1&pageSize=10&_sort[0]=id:DESC&_sort[1]=age:DESC&_where[0][status_lte]=1&_where[1][alarm_time_lte]=2022-07-01T04:00:00.000Z&_where[2][content_contains]=1

type Condition struct {
	Page     int
	PageSize int
	Sorts    []*Item
	Wheres   []*Item
}

type QueryMethod string

const (
	GT        QueryMethod = "gt"
	GTE       QueryMethod = "gte"
	EQ        QueryMethod = "eq"
	LT        QueryMethod = "lt"
	LTE       QueryMethod = "lte"
	CONTAINS  QueryMethod = "contains"
	CONTAINSS QueryMethod = "containss"
)

type Item struct {
	Field string
	// > >= = < <= contains containss
	// gt gte eq lt lte contains containss
	Method QueryMethod
	Value  string
}

func ParseQuerys(querys url.Values) *Condition {
	var cond = Condition{
		Page:     1,
		PageSize: 10,
		Sorts:    make([]*Item, 0),
		Wheres:   make([]*Item, 0),
	}

	if _page := querys.Get("page"); _page != "" {
		ipage, err := strconv.Atoi(_page)
		if err == nil {
			cond.Page = ipage
		}
	}
	if _pageSize := querys.Get("pageSize"); _pageSize != "" {
		ipageSize, err := strconv.Atoi(_pageSize)
		if err == nil {
			cond.PageSize = ipageSize
		}
	}

	condReg, _ := regexp.Compile(`_where\[\d+\]\[(.*?)\]`)
	for k, v := range querys {
		if strings.HasPrefix(k, "_sort") && len(v) > 0 {
			tmp := strings.Split(v[0], ":")
			cond.Sorts = append(cond.Sorts, &Item{Field: tmp[0], Value: tmp[1]})
		}
		if strings.HasPrefix(k, "_where") && len(v) > 0 {
			match := condReg.FindStringSubmatch(k)
			tmps := strings.Split(match[1], "_")
			_method := QueryMethod(tmps[len(tmps)-1])
			_field := strings.Join(tmps[0:len(tmps)-1], "_")
			cond.Wheres = append(cond.Wheres, &Item{Field: _field, Method: _method, Value: v[0]})
		}
	}

	return &cond
}
